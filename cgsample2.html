<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>CG2</title>
</head>

<body>

  <h1>課題 2 (1)</h1>
  <script>

    const width = 40
    const height = 30
    let frameMemory = Array(width * height)
    frameMemory.fill('&nbsp;')

    function point(x, y) {
      frameMemory[width * Math.round(y) + Math.round(x)] = '*'
    }

    function print() {
      document.write('<pre>');
      for (let y = 0; y < height; ++y) {
        for (let x = 0; x < width; ++x) {
          document.write(frameMemory[width * y + x])
        }
        document.writeln()
      }
      document.write('</pre>')
    }

    // 水平線を描く
    function hline(x0, x1, y) {
      for (let x = x0; x <= x1; ++x) {
        point(x, y)
      }
    }

    // 領域を塗りつぶす
    function fill(x0, y0, x1, y1) {
      for (let y = y0; y <= y1; ++y) {
        hline(x0, x1, y)
      }
    }
    function sin(w, h) {
      let x1
      let y1
      for (let x = 0; x <=w-1 ; x++) {
        let y
        y=h/2-h/2*Math.sin(2*Math.PI*x/w)
        point(x,y)
      }
    }

    // 以下を課題 2 (1) の図形を描くスクリプトに書き換えてください
    sin(40, 29)

    // 結果を表示する
    print()

  </script>

  <script id="vertex-shader" type="x-shader/x-vertex">
    #version 300 es
    //
    // バーテックスシェーダのソースプログラム
    //
    precision mediump float;

    layout (location = 0) in vec4 position;

    void main()
    {
      gl_Position = position;
    }
  </script>
  <script id="fragment-shader" type="x-shader/x-fragment">
    #version 300 es
    //
    // フラグメントシェーダのソースプログラム
    //
    precision mediump float;

    layout (location = 0) out vec4 color;

    void main()
    {
      color = vec4(1.0, 1.0, 0.0, 1.0);
    }
  </script>
  <script>
    'use strict'

    //
    // シェーダのソースプログラムを読み込んでコンパイルする
    //
    function compileShader(id) {

      // シェーダの種類
      const type = {
        "x-shader/x-vertex": gl.VERTEX_SHADER,
        "x-shader/x-fragment": gl.FRAGMENT_SHADER
      }

      // シェーダのソースプログラムを読み込む
      const element = document.getElementById(id)
      const source = element.text.trim()

      // シェーダのソースプログラムをコンパイルする
      const shader = gl.createShader(type[element.type])
      gl.shaderSource(shader, source)
      gl.compileShader(shader)

      // コンパイルエラーが発生していたらエラーメッセージを表示する
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(element.type + ':\n'
          + gl.getShaderInfoLog(shader))
        gl.deleteShader(shader);
        return null
      }

      return shader;
    }

    //
    // プログラムオブジェクトを作成する
    //
    function loadShader(vertId, fragId) {

      // バーテックスシェーダをコンパイルする
      const vertShader = compileShader(vertId)

      // フラグメントシェーダをコンパイルする
      const fragShader = compileShader(fragId)

      // エラーが発生していればプログラムオブジェクトを作成しない
      if (!vertShader || !fragShader) return null

      // プログラムオブジェクトを作成する
      const program = gl.createProgram()

      // バーテックスシェーダとフラグメントシェーダをリンクする
      gl.attachShader(program, vertShader)
      gl.deleteShader(vertShader)
      gl.attachShader(program, fragShader)
      gl.deleteShader(fragShader)
      gl.linkProgram(program)

      // リンクエラーが発生していたらエラーメッセージを表示する
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Link: ' + gl.getProgramInfoLog(program))
        gl.deleteProgram(program)
        return null
      }

      // 作成されたプログラムオブジェクトを返す
      return program
    }

    //
    // 頂点配列オブジェクトを作成する
    //
    function createObject(position) {

      // 頂点配列オブジェクトを作成する
      const vao = gl.createVertexArray()

      // 頂点配列オブジェクトを結合する
      gl.bindVertexArray(vao)

      // バッファオブジェクトを作成する
      const vbo = gl.createBuffer()

      // 作成したバッファオブジェクトを頂点バッファとして結合する
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo)

      // 頂点バッファオブジェクトのバッファを確保してデータを転送する
      gl.bufferData(gl.ARRAY_BUFFER,
        new Float32Array(position), gl.STATIC_DRAW)

      // 頂点バッファオブジェクトの先頭のインデックスを 0 に設定する
      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)

      // 0 番のインデックスを有効にする
      gl.enableVertexAttribArray(0)

      // 頂点バッファオブジェクトの結合を解除する
      gl.bindBuffer(gl.ARRAY_BUFFER, null)

      // 頂点配列オブジェクトの結合を解除する
      gl.bindVertexArray(null)

      // 作成した頂点配列オブジェクトと頂点数を返す
      return { vao: vao, count: Math.floor(position.length / 2) }
    }

    //
    // 描画する
    //
    function draw(object) {

      //カンバス内の表示を消去する
      gl.clear(gl.COLOR_BUFFER_BIT)

      // 描画する頂点配列オブジェクト（図形）を指定する
      gl.bindVertexArray(object.vao)

      // 図形を描画する
      gl.drawArrays(gl.LINE_STRIP, 0, object.count)

      // 頂点配列オブジェクトの指定を解除する
      gl.bindVertexArray(null)
    }
  </script>

<h1>課題 2 (2)</h1>
<canvas id="CG2" width="400" height="300" style="border: inset;">
    HTML5 の canvas が使えません
  </canvas>
  <script>
    const canvas = document.getElementById("CG2")
    const gl = canvas.getContext('webgl2')

    gl.viewport(0, 0, canvas.width, canvas.height)
    gl.clearColor(0.2, 0.3, 0.4, 1.0)

    // 課題 2 (2)
    const position = [
      0.8 * height / width * Math.sin(0), 0.8 * Math.cos(0),
      0.8 * height / width * Math.sin(Math.PI * 4 / 5), 0.8 * Math.cos(Math.PI * 4 / 5),
      0.8 * height / width * Math.sin(Math.PI * 8 / 5), 0.8 * Math.cos(Math.PI * 8 / 5),
      0.8 * height / width * Math.sin(Math.PI * 2 / 5), 0.8 * Math.cos(Math.PI * 2 / 5),
      0.8 * height / width * Math.sin(Math.PI * 6 / 5), 0.8 * Math.cos(Math.PI * 6 / 5),
      0.8 * height / width * Math.sin(0), 0.8 * Math.cos(0),
    ]

    const shader = loadShader('vertex-shader', 'fragment-shader')
    const object = createObject(position)
    gl.useProgram(shader)
    draw(object)
    gl.useProgram(null)
  </script>
</body>

</html>